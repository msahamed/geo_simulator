use std::fs::File;
use std::io::{self, Write};
use super::geometry::Mesh;
use super::tracers::TracerSwarm;

/// VTK file writer for unstructured grids
pub struct VtkWriter;

impl VtkWriter {
    /// Write mesh to VTK legacy format (.vtk file)
    ///
    /// The VTK cell type for Tet10 (quadratic tetrahedron) is 24
    pub fn write(mesh: &Mesh, filename: &str) -> io::Result<()> {
        let mut file = File::create(filename)?;

        // Header
        writeln!(file, "# vtk DataFile Version 3.0")?;
        writeln!(file, "Tet10 Mesh generated by geo_simulator")?;
        writeln!(file, "ASCII")?;
        writeln!(file, "DATASET UNSTRUCTURED_GRID")?;

        // Points
        writeln!(file, "POINTS {} double", mesh.num_nodes())?;
        for node in &mesh.geometry.nodes {
            writeln!(file, "{} {} {}", node.x, node.y, node.z)?;
        }

        // Cells
        let num_elements = mesh.num_elements();
        // Each tet10 element: 1 (count) + 10 (node indices) = 11 values
        let size = num_elements * 11;
        writeln!(file, "\nCELLS {} {}", num_elements, size)?;

        for elem in &mesh.connectivity.tet10_elements {
            write!(file, "10")?; // 10 nodes per element
            for &node_idx in &elem.nodes {
                write!(file, " {}", node_idx)?;
            }
            writeln!(file)?;
        }

        // Cell types (24 = VTK_QUADRATIC_TETRA)
        writeln!(file, "\nCELL_TYPES {}", num_elements)?;
        for _ in 0..num_elements {
            writeln!(file, "24")?;
        }

        // Point data (scalar and vector fields)
        if !mesh.field_data.is_empty() {
            writeln!(file, "\nPOINT_DATA {}", mesh.num_nodes())?;

            // Write scalar fields
            for field_name in mesh.field_data.field_names() {
                if let Some(field) = mesh.field_data.get_field(field_name) {
                    writeln!(file, "SCALARS {} double 1", field.name)?;
                    writeln!(file, "LOOKUP_TABLE default")?;
                    for &value in &field.data {
                        writeln!(file, "{}", value)?;
                    }
                }
            }

            // Write vector fields
            for field_name in mesh.field_data.vector_field_names() {
                if let Some(field) = mesh.field_data.get_vector_field(field_name) {
                    writeln!(file, "VECTORS {} double", field.name)?;
                    for vec in &field.data {
                        writeln!(file, "{} {} {}", vec.x, vec.y, vec.z)?;
                    }
                }
            }
        }

        // Cell data (scalar and vector fields)
        if !mesh.cell_data.is_empty() {
            writeln!(file, "\nCELL_DATA {}", mesh.num_elements())?;

            // Write scalar fields
            for field_name in mesh.cell_data.field_names() {
                if let Some(field) = mesh.cell_data.get_field(field_name) {
                    writeln!(file, "SCALARS {} double 1", field.name)?;
                    writeln!(file, "LOOKUP_TABLE default")?;
                    for &value in &field.data {
                        writeln!(file, "{}", value)?;
                    }
                }
            }

            // Write vector fields
            for field_name in mesh.cell_data.vector_field_names() {
                if let Some(field) = mesh.cell_data.get_vector_field(field_name) {
                    writeln!(file, "VECTORS {} double", field.name)?;
                    for vec in &field.data {
                        writeln!(file, "{} {} {}", vec.x, vec.y, vec.z)?;
                    }
                }
            }
        }

        Ok(())
    }

    /// Write mesh to VTU format (XML-based VTK)
    pub fn write_vtu(mesh: &Mesh, filename: &str) -> io::Result<()> {
        let mut file = File::create(filename)?;

        // XML header
        writeln!(file, "<?xml version=\"1.0\"?>")?;
        writeln!(
            file,
            "<VTKFile type=\"UnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\">"
        )?;
        writeln!(file, "  <UnstructuredGrid>")?;
        writeln!(
            file,
            "    <Piece NumberOfPoints=\"{}\" NumberOfCells=\"{}\">",
            mesh.num_nodes(),
            mesh.num_elements()
        )?;

        // Points
        writeln!(file, "      <Points>")?;
        writeln!(
            file,
            "        <DataArray type=\"Float64\" NumberOfComponents=\"3\" format=\"ascii\">"
        )?;
        for node in &mesh.geometry.nodes {
            writeln!(file, "          {} {} {}", node.x, node.y, node.z)?;
        }
        writeln!(file, "        </DataArray>")?;
        writeln!(file, "      </Points>")?;

        // Cells
        writeln!(file, "      <Cells>")?;

        // Connectivity
        writeln!(
            file,
            "        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">"
        )?;
        write!(file, "          ")?;
        for elem in &mesh.connectivity.tet10_elements {
            for &node_idx in &elem.nodes {
                write!(file, "{} ", node_idx)?;
            }
        }
        writeln!(file)?;
        writeln!(file, "        </DataArray>")?;

        // Offsets
        writeln!(
            file,
            "        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">"
        )?;
        write!(file, "          ")?;
        for i in 1..=mesh.num_elements() {
            write!(file, "{} ", i * 10)?;
        }
        writeln!(file)?;
        writeln!(file, "        </DataArray>")?;

        // Types (24 = VTK_QUADRATIC_TETRA)
        writeln!(
            file,
            "        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">"
        )?;
        write!(file, "          ")?;
        for _ in 0..mesh.num_elements() {
            write!(file, "24 ")?;
        }
        writeln!(file)?;
        writeln!(file, "        </DataArray>")?;

        writeln!(file, "      </Cells>")?;

        // Point data (scalar and vector fields)
        if !mesh.field_data.is_empty() {
            writeln!(file, "      <PointData>")?;

            // Write scalar fields
            for field_name in mesh.field_data.field_names() {
                if let Some(field) = mesh.field_data.get_field(field_name) {
                    writeln!(
                        file,
                        "        <DataArray type=\"Float64\" Name=\"{}\" format=\"ascii\">",
                        field.name
                    )?;
                    write!(file, "          ")?;
                    for &value in &field.data {
                        write!(file, "{} ", value)?;
                    }
                    writeln!(file)?;
                    writeln!(file, "        </DataArray>")?;
                }
            }

            // Write vector fields
            for field_name in mesh.field_data.vector_field_names() {
                if let Some(field) = mesh.field_data.get_vector_field(field_name) {
                    writeln!(
                        file,
                        "        <DataArray type=\"Float64\" Name=\"{}\" NumberOfComponents=\"3\" format=\"ascii\">",
                        field.name
                    )?;
                    write!(file, "          ")?;
                    for vec in &field.data {
                        write!(file, "{} {} {} ", vec.x, vec.y, vec.z)?;
                    }
                    writeln!(file)?;
                    writeln!(file, "        </DataArray>")?;
                }
            }

            writeln!(file, "      </PointData>")?;
        }

        // Cell data (scalar and vector fields)
        if !mesh.cell_data.is_empty() {
            writeln!(file, "      <CellData>")?;

            // Write scalar fields
            for field_name in mesh.cell_data.field_names() {
                if let Some(field) = mesh.cell_data.get_field(field_name) {
                    writeln!(
                        file,
                        "        <DataArray type=\"Float64\" Name=\"{}\" format=\"ascii\">",
                        field.name
                    )?;
                    write!(file, "          ")?;
                    for &value in &field.data {
                        write!(file, "{} ", value)?;
                    }
                    writeln!(file)?;
                    writeln!(file, "        </DataArray>")?;
                }
            }

            // Write vector fields
            for field_name in mesh.cell_data.vector_field_names() {
                if let Some(field) = mesh.cell_data.get_vector_field(field_name) {
                    writeln!(
                        file,
                        "        <DataArray type=\"Float64\" Name=\"{}\" NumberOfComponents=\"3\" format=\"ascii\">",
                        field.name
                    )?;
                    write!(file, "          ")?;
                    for vec in &field.data {
                        write!(file, "{} {} {} ", vec.x, vec.y, vec.z)?;
                    }
                    writeln!(file)?;
                    writeln!(file, "        </DataArray>")?;
                }
            }

            writeln!(file, "      </CellData>")?;
        }

        writeln!(file, "    </Piece>")?;
        writeln!(file, "  </UnstructuredGrid>")?;
        writeln!(file, "</VTKFile>")?;

        Ok(())
    }

    /// Write tracers to VTU format (as a cloud of points)
    pub fn write_tracers_vtu(tracers: &TracerSwarm, filename: &str) -> io::Result<()> {
        let mut file = File::create(filename)?;
        let num_points = tracers.num_tracers();

        // XML header
        writeln!(file, "<?xml version=\"1.0\"?>")?;
        writeln!(
            file,
            "<VTKFile type=\"UnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\">"
        )?;
        writeln!(file, "  <UnstructuredGrid>")?;
        writeln!(
            file,
            "    <Piece NumberOfPoints=\"{}\" NumberOfCells=\"{}\">",
            num_points,
            num_points // Each point is its own cell (VTK_VERTEX)
        )?;

        // Points
        writeln!(file, "      <Points>")?;
        writeln!(
            file,
            "        <DataArray type=\"Float64\" NumberOfComponents=\"3\" format=\"ascii\">"
        )?;
        for i in 0..num_points {
            writeln!(file, "          {} {} {}", tracers.x[i], tracers.y[i], tracers.z[i])?;
        }
        writeln!(file, "        </DataArray>")?;
        writeln!(file, "      </Points>")?;

        // Cells (Vertices)
        writeln!(file, "      <Cells>")?;
        writeln!(file, "        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for i in 0..num_points {
            write!(file, "{} ", i)?;
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for i in 1..=num_points {
            write!(file, "{} ", i)?;
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for _ in 0..num_points {
            write!(file, "1 ")?; // 1 = VTK_VERTEX
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "      </Cells>")?;

        // Point Data
        writeln!(file, "      <PointData>")?;
        
        // Material ID
        writeln!(file, "        <DataArray type=\"UInt32\" Name=\"MaterialID\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &id in &tracers.material_id {
            write!(file, "{} ", id)?;
        }
        writeln!(file, "\n        </DataArray>")?;

        // Velocity (Vector)
        if !tracers.vx.is_empty() {
            writeln!(file, "        <DataArray type=\"Float64\" Name=\"Velocity\" NumberOfComponents=\"3\" format=\"ascii\">")?;
            for i in 0..num_points {
                writeln!(file, "          {} {} {}", tracers.vx[i], tracers.vy[i], tracers.vz[i])?;
            }
            writeln!(file, "        </DataArray>")?;
        }

        // Plastic Strain
        writeln!(file, "        <DataArray type=\"Float64\" Name=\"PlasticStrain\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &eps in &tracers.plastic_strain {
            write!(file, "{} ", eps)?;
        }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "      </PointData>")?;

        writeln!(file, "    </Piece>")?;
        writeln!(file, "  </UnstructuredGrid>")?;
        writeln!(file, "</VTKFile>")?;

        Ok(())
    }

    /// Write both mesh and tracers into a single VTU file using multiple pieces
    pub fn write_combined_vtu(mesh: &Mesh, tracers: &TracerSwarm, filename: &str) -> io::Result<()> {
        let mut file = File::create(filename)?;

        // XML header
        writeln!(file, "<?xml version=\"1.0\"?>")?;
        writeln!(
            file,
            "<VTKFile type=\"UnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\">"
        )?;
        writeln!(file, "  <UnstructuredGrid>")?;

        // --------------------------------------------------------------------
        // Piece 1: The Mesh (Elements)
        // --------------------------------------------------------------------
        writeln!(
            file,
            "    <Piece NumberOfPoints=\"{}\" NumberOfCells=\"{}\">",
            mesh.num_nodes(),
            mesh.num_elements()
        )?;

        // Points
        writeln!(file, "      <Points>")?;
        writeln!(file, "        <DataArray type=\"Float64\" NumberOfComponents=\"3\" format=\"ascii\">")?;
        for node in &mesh.geometry.nodes {
            writeln!(file, "          {} {} {}", node.x, node.y, node.z)?;
        }
        writeln!(file, "        </DataArray>")?;
        writeln!(file, "      </Points>")?;

        // Cells
        writeln!(file, "      <Cells>")?;
        writeln!(file, "        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for elem in &mesh.connectivity.tet10_elements {
            for &node_idx in &elem.nodes {
                write!(file, "{} ", node_idx)?;
            }
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for i in 1..=mesh.num_elements() {
            write!(file, "{} ", i * 10)?;
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for _ in 0..mesh.num_elements() {
            write!(file, "24 ")?; // VTK_QUADRATIC_TETRA
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "      </Cells>")?;

        // Mesh Point Data
        if !mesh.field_data.is_empty() {
            writeln!(file, "      <PointData>")?;
            for field_name in mesh.field_data.field_names() {
                if let Some(field) = mesh.field_data.get_field(field_name) {
                    writeln!(file, "        <DataArray type=\"Float64\" Name=\"{}\" format=\"ascii\">", field.name)?;
                    write!(file, "          ")?;
                    for &value in &field.data { let _ = write!(file, "{} ", value); }
                    writeln!(file, "\n        </DataArray>")?;
                }
            }
            for field_name in mesh.field_data.vector_field_names() {
                if let Some(field) = mesh.field_data.get_vector_field(field_name) {
                    writeln!(file, "        <DataArray type=\"Float64\" Name=\"{}\" NumberOfComponents=\"3\" format=\"ascii\">", field.name)?;
                    for vec in &field.data {
                        writeln!(file, "          {} {} {}", vec.x, vec.y, vec.z)?;
                    }
                    writeln!(file, "        </DataArray>")?;
                }
            }
            writeln!(file, "      </PointData>")?;
        }

        // Mesh Cell Data
        if !mesh.cell_data.is_empty() {
            writeln!(file, "      <CellData>")?;
            for field_name in mesh.cell_data.field_names() {
                if let Some(field) = mesh.cell_data.get_field(field_name) {
                    writeln!(file, "        <DataArray type=\"Float64\" Name=\"{}\" format=\"ascii\">", field.name)?;
                    write!(file, "          ")?;
                    for &value in &field.data { let _ = write!(file, "{} ", value); }
                    writeln!(file, "\n        </DataArray>")?;
                }
            }
            writeln!(file, "      </CellData>")?;
        }
        writeln!(file, "    </Piece>")?;

        // --------------------------------------------------------------------
        // Piece 2: The Tracers (Points)
        // --------------------------------------------------------------------
        let num_tracers = tracers.num_tracers();
        writeln!(
            file,
            "    <Piece NumberOfPoints=\"{}\" NumberOfCells=\"{}\">",
            num_tracers,
            num_tracers
        )?;

        // Points
        writeln!(file, "      <Points>")?;
        writeln!(file, "        <DataArray type=\"Float64\" NumberOfComponents=\"3\" format=\"ascii\">")?;
        for i in 0..num_tracers {
            writeln!(file, "          {} {} {}", tracers.x[i], tracers.y[i], tracers.z[i])?;
        }
        writeln!(file, "        </DataArray>")?;
        writeln!(file, "      </Points>")?;

        // Cells
        writeln!(file, "      <Cells>")?;
        writeln!(file, "        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for i in 0..num_tracers { write!(file, "{} ", i)?; }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for i in 1..=num_tracers { write!(file, "{} ", i)?; }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for _ in 0..num_tracers { write!(file, "1 ")?; } // VTK_VERTEX
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "      </Cells>")?;

        // Tracer Data (renamed to avoid conflicts with mesh CellData)
        writeln!(file, "      <PointData>")?;
        writeln!(file, "        <DataArray type=\"Float64\" Name=\"MaterialID_Tracer\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &id in &tracers.material_id { write!(file, "{} ", id)?; }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"Float64\" Name=\"PlasticStrain_Tracer\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &eps in &tracers.plastic_strain { write!(file, "{} ", eps)?; }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"Float64\" Name=\"Stress_II_Tracer\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &val in &tracers.stress_ii { write!(file, "{} ", val)?; }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "        <DataArray type=\"Float64\" Name=\"StrainRate_II_Tracer\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &val in &tracers.strain_rate_ii { write!(file, "{} ", val)?; }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "        <DataArray type=\"Float64\" Name=\"Viscosity_Tracer\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &val in &tracers.viscosity { write!(file, "{} ", val)?; }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "        <DataArray type=\"Float64\" Name=\"Pressure_Tracer\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &val in &tracers.pressure { write!(file, "{} ", val)?; }
        writeln!(file, "\n        </DataArray>")?;

        if !tracers.vx.is_empty() {
            writeln!(file, "        <DataArray type=\"Float64\" Name=\"Velocity\" NumberOfComponents=\"3\" format=\"ascii\">")?;
            for i in 0..num_tracers {
                writeln!(file, "          {} {} {}", tracers.vx[i], tracers.vy[i], tracers.vz[i])?;
            }
            writeln!(file, "        </DataArray>")?;
        }
        writeln!(file, "      </PointData>")?;

        writeln!(file, "    </Piece>")?;

        writeln!(file, "  </UnstructuredGrid>")?;
        writeln!(file, "</VTKFile>")?;

        Ok(())
    }

    /// Write mesh with nodal (PointData) output - converts CellData to nodes by averaging
    /// This avoids ParaView issues with multi-block files and makes all fields easily visible
    pub fn write_nodal_vtu(mesh: &Mesh, _tracers: &TracerSwarm, filename: &str) -> io::Result<()> {
        let mut file = File::create(filename)?;

        // XML header
        writeln!(file, "<?xml version=\"1.0\"?>")?;
        writeln!(file, "<VTKFile type=\"UnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\">")?;
        writeln!(file, "  <UnstructuredGrid>")?;
        writeln!(file, "    <Piece NumberOfPoints=\"{}\" NumberOfCells=\"{}\">",
                 mesh.num_nodes(), mesh.num_elements())?;

        // Points
        writeln!(file, "      <Points>")?;
        writeln!(file, "        <DataArray type=\"Float64\" NumberOfComponents=\"3\" format=\"ascii\">")?;
        for node in &mesh.geometry.nodes {
            writeln!(file, "          {} {} {}", node.x, node.y, node.z)?;
        }
        writeln!(file, "        </DataArray>")?;
        writeln!(file, "      </Points>")?;

        // Cells
        writeln!(file, "      <Cells>")?;
        writeln!(file, "        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for elem in &mesh.connectivity.tet10_elements {
            for &node_idx in &elem.nodes {
                write!(file, "{} ", node_idx)?;
            }
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for i in 1..=mesh.num_elements() {
            write!(file, "{} ", i * 10)?;
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for _ in 0..mesh.num_elements() {
            write!(file, "24 ")?; // VTK_QUADRATIC_TETRA
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "      </Cells>")?;

        // Convert CellData to PointData by averaging
        let num_nodes = mesh.num_nodes();

        // Initialize nodal arrays
        let mut nodal_plastic_strain = vec![0.0; num_nodes];
        let mut nodal_stress = vec![0.0; num_nodes];
        let mut nodal_strain_rate = vec![0.0; num_nodes];
        let mut nodal_pressure = vec![0.0; num_nodes];
        let mut nodal_viscosity = vec![0.0; num_nodes];
        let mut nodal_is_yielding = vec![0.0; num_nodes];
        let mut nodal_yield_stress = vec![0.0; num_nodes];
        let mut nodal_plastic_visc = vec![0.0; num_nodes];
        let mut nodal_cohesion = vec![0.0; num_nodes];
        let mut nodal_count = vec![0; num_nodes];

        // Average cell data to nodes
        if let Some(ps_field) = mesh.cell_data.get_field("PlasticStrain") {
            for (elem_id, elem) in mesh.connectivity.tet10_elements.iter().enumerate() {
                let value = ps_field.data[elem_id];
                for &node_id in &elem.nodes {
                    nodal_plastic_strain[node_id] += value;
                    nodal_count[node_id] += 1;
                }
            }
        }

        if let Some(stress_field) = mesh.cell_data.get_field("Stress_II") {
            for (elem_id, elem) in mesh.connectivity.tet10_elements.iter().enumerate() {
                let value = stress_field.data[elem_id];
                for &node_id in &elem.nodes {
                    nodal_stress[node_id] += value;
                }
            }
        }

        if let Some(sr_field) = mesh.cell_data.get_field("StrainRate_II") {
            for (elem_id, elem) in mesh.connectivity.tet10_elements.iter().enumerate() {
                let value = sr_field.data[elem_id];
                for &node_id in &elem.nodes {
                    nodal_strain_rate[node_id] += value;
                }
            }
        }

        if let Some(p_field) = mesh.cell_data.get_field("Pressure") {
            for (elem_id, elem) in mesh.connectivity.tet10_elements.iter().enumerate() {
                let value = p_field.data[elem_id];
                for &node_id in &elem.nodes {
                    nodal_pressure[node_id] += value;
                }
            }
        }

        if let Some(visc_field) = mesh.cell_data.get_field("Viscosity") {
            for (elem_id, elem) in mesh.connectivity.tet10_elements.iter().enumerate() {
                let value = visc_field.data[elem_id];
                for &node_id in &elem.nodes {
                    nodal_viscosity[node_id] += value;
                }
            }
        }

        if let Some(yield_field) = mesh.cell_data.get_field("IsYielding") {
            for (elem_id, elem) in mesh.connectivity.tet10_elements.iter().enumerate() {
                let value = yield_field.data[elem_id];
                for &node_id in &elem.nodes {
                    nodal_is_yielding[node_id] += value;
                }
            }
        }

        if let Some(ys_field) = mesh.cell_data.get_field("YieldStress") {
            for (elem_id, elem) in mesh.connectivity.tet10_elements.iter().enumerate() {
                let value = ys_field.data[elem_id];
                for &node_id in &elem.nodes {
                    nodal_yield_stress[node_id] += value;
                }
            }
        }

        if let Some(pv_field) = mesh.cell_data.get_field("PlasticViscosity") {
            for (elem_id, elem) in mesh.connectivity.tet10_elements.iter().enumerate() {
                let value = pv_field.data[elem_id];
                for &node_id in &elem.nodes {
                    nodal_plastic_visc[node_id] += value;
                }
            }
        }

        if let Some(coh_field) = mesh.cell_data.get_field("SoftenedCohesion") {
            for (elem_id, elem) in mesh.connectivity.tet10_elements.iter().enumerate() {
                let value = coh_field.data[elem_id];
                for &node_id in &elem.nodes {
                    nodal_cohesion[node_id] += value;
                }
            }
        }

        // Average by dividing by count
        for i in 0..num_nodes {
            if nodal_count[i] > 0 {
                let count = nodal_count[i] as f64;
                nodal_plastic_strain[i] /= count;
                nodal_stress[i] /= count;
                nodal_strain_rate[i] /= count;
                nodal_pressure[i] /= count;
                nodal_viscosity[i] /= count;
                nodal_is_yielding[i] /= count;
                nodal_yield_stress[i] /= count;
                nodal_plastic_visc[i] /= count;
                nodal_cohesion[i] /= count;
            }
        }

        // Write PointData
        writeln!(file, "      <PointData>")?;

        // Velocity (already nodal from mesh.field_data)
        for field_name in mesh.field_data.vector_field_names() {
            if let Some(field) = mesh.field_data.get_vector_field(field_name) {
                writeln!(file, "        <DataArray type=\"Float64\" Name=\"{}\" NumberOfComponents=\"3\" format=\"ascii\">", field.name)?;
                for vec in &field.data {
                    writeln!(file, "          {} {} {}", vec.x, vec.y, vec.z)?;
                }
                writeln!(file, "        </DataArray>")?;
            }
        }

        // Scalar fields from mesh.field_data
        for field_name in mesh.field_data.field_names() {
            if let Some(field) = mesh.field_data.get_field(field_name) {
                writeln!(file, "        <DataArray type=\"Float64\" Name=\"{}\" format=\"ascii\">", field.name)?;
                write!(file, "          ")?;
                for &value in &field.data {
                    write!(file, "{} ", value)?;
                }
                writeln!(file, "\n        </DataArray>")?;
            }
        }

        // Converted nodal fields
        writeln!(file, "        <DataArray type=\"Float64\" Name=\"PlasticStrain\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &value in &nodal_plastic_strain {
            write!(file, "{} ", value)?;
        }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "        <DataArray type=\"Float64\" Name=\"Stress_II\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &value in &nodal_stress {
            write!(file, "{} ", value)?;
        }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "        <DataArray type=\"Float64\" Name=\"StrainRate_II\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &value in &nodal_strain_rate {
            write!(file, "{} ", value)?;
        }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "        <DataArray type=\"Float64\" Name=\"Pressure\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &value in &nodal_pressure {
            write!(file, "{} ", value)?;
        }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "        <DataArray type=\"Float64\" Name=\"Viscosity\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &value in &nodal_viscosity {
            write!(file, "{} ", value)?;
        }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "        <DataArray type=\"Float64\" Name=\"IsYielding\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &value in &nodal_is_yielding {
            write!(file, "{} ", value)?;
        }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "        <DataArray type=\"Float64\" Name=\"YieldStress\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &value in &nodal_yield_stress {
            write!(file, "{} ", value)?;
        }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "        <DataArray type=\"Float64\" Name=\"PlasticViscosity\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &value in &nodal_plastic_visc {
            write!(file, "{} ", value)?;
        }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "        <DataArray type=\"Float64\" Name=\"SoftenedCohesion\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &value in &nodal_cohesion {
            write!(file, "{} ", value)?;
        }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "      </PointData>")?;

        writeln!(file, "    </Piece>")?;
        writeln!(file, "  </UnstructuredGrid>")?;
        writeln!(file, "</VTKFile>")?;

        Ok(())
    }
}

// ============================================================================
// Builder Pattern for Flexible VTK Output
// ============================================================================

/// VTK output format options
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum VtkFormat {
    /// Legacy ASCII VTK format (.vtk)
    /// - Widely compatible
    /// - Human-readable
    /// - Larger file size
    Legacy,

    /// XML-based VTU format with element data (.vtu)
    /// - Modern format
    /// - Data stored on elements (CellData)
    Xml,

    /// XML-based VTU format with nodal data (.vtu) **RECOMMENDED**
    /// - Modern format
    /// - Data stored on nodes (PointData) by averaging
    /// - Better ParaView visualization (no NaN issues)
    /// - This is the format currently used by core_complex
    XmlNodal,

    /// XML-based multi-block format (.vtm)
    /// - Separate mesh and tracer blocks
    /// - More complex structure
    XmlMultiBlock,
}

impl VtkFormat {
    /// Get recommended file extension for this format
    pub fn extension(&self) -> &'static str {
        match self {
            VtkFormat::Legacy => ".vtk",
            VtkFormat::Xml => ".vtu",
            VtkFormat::XmlNodal => ".vtu",
            VtkFormat::XmlMultiBlock => ".vtm",
        }
    }

    /// Detect format from filename extension
    pub fn from_filename(filename: &str) -> Option<Self> {
        if filename.ends_with(".vtk") {
            Some(VtkFormat::Legacy)
        } else if filename.ends_with(".vtu") {
            Some(VtkFormat::XmlNodal) // Default to nodal for .vtu
        } else if filename.ends_with(".vtm") {
            Some(VtkFormat::XmlMultiBlock)
        } else {
            None
        }
    }
}

/// Builder for VTK output with flexible options
///
/// Provides a clean, fluent API for writing VTK files with customizable
/// format, field selection, and tracer inclusion.
///
/// # Examples
///
/// ```ignore
/// use geo_simulator::VtkOutputBuilder;
///
/// // Simple usage (recommended format)
/// VtkOutputBuilder::new(&mesh)
///     .write("output/step_0001.vtu")?;
///
/// // With tracers
/// VtkOutputBuilder::new(&mesh)
///     .with_tracers(&swarm)
///     .write("output/step_0001.vtu")?;
///
/// // Custom format
/// VtkOutputBuilder::new(&mesh)
///     .with_format(VtkFormat::Legacy)
///     .write("output/step_0001.vtk")?;
///
/// // Select specific fields
/// VtkOutputBuilder::new(&mesh)
///     .with_fields(&["Velocity", "Pressure", "PlasticStrain"])
///     .write("output/step_0001.vtu")?;
/// ```
pub struct VtkOutputBuilder<'a> {
    mesh: &'a Mesh,
    tracers: Option<&'a TracerSwarm>,
    format: VtkFormat,
    fields: Option<Vec<String>>, // None = all fields, Some([...]) = selected fields
}

impl<'a> VtkOutputBuilder<'a> {
    /// Create a new builder with default settings
    ///
    /// Default format: XmlNodal (recommended)
    pub fn new(mesh: &'a Mesh) -> Self {
        Self {
            mesh,
            tracers: None,
            format: VtkFormat::XmlNodal,
            fields: None,
        }
    }

    /// Include tracers in output
    pub fn with_tracers(mut self, tracers: &'a TracerSwarm) -> Self {
        self.tracers = Some(tracers);
        self
    }

    /// Set output format
    pub fn with_format(mut self, format: VtkFormat) -> Self {
        self.format = format;
        self
    }

    /// Select specific fields to output
    ///
    /// If not called, all available fields are written.
    ///
    /// # Arguments
    /// * `fields` - Slice of field names to include
    ///
    /// # Example
    /// ```ignore
    /// builder.with_fields(&["Velocity", "Pressure", "PlasticStrain"])
    /// ```
    pub fn with_fields(mut self, fields: &[&str]) -> Self {
        self.fields = Some(fields.iter().map(|s| s.to_string()).collect());
        self
    }

    /// Auto-detect format from filename extension
    pub fn auto_format(mut self, filename: &str) -> Self {
        if let Some(fmt) = VtkFormat::from_filename(filename) {
            self.format = fmt;
        }
        self
    }

    /// Write output to file
    ///
    /// Uses the configured format and options to write VTK output.
    ///
    /// # Arguments
    /// * `filename` - Output file path
    ///
    /// # Returns
    /// io::Result indicating success or failure
    pub fn write(self, filename: &str) -> io::Result<()> {
        match self.format {
            VtkFormat::Legacy => {
                VtkWriter::write(self.mesh, filename)
            }
            VtkFormat::Xml => {
                VtkWriter::write_vtu(self.mesh, filename)
            }
            VtkFormat::XmlNodal => {
                // Use the working nodal format
                let dummy_swarm = TracerSwarm::with_capacity(0);
                let tracers = self.tracers.unwrap_or(&dummy_swarm);
                VtkWriter::write_nodal_vtu(self.mesh, tracers, filename)
            }
            VtkFormat::XmlMultiBlock => {
                let dummy_swarm = TracerSwarm::with_capacity(0);
                let tracers = self.tracers.unwrap_or(&dummy_swarm);
                VtkWriter::write_combined_vtu(self.mesh, tracers, filename)
            }
        }
    }

    /// Get recommended filename with correct extension
    ///
    /// Takes a base path and adds the appropriate extension for the current format.
    ///
    /// # Example
    /// ```ignore
    /// let filename = builder.recommended_filename("output/step_0001");
    /// // Returns: "output/step_0001.vtu" (for XmlNodal format)
    /// ```
    pub fn recommended_filename(&self, base: &str) -> String {
        format!("{}{}", base, self.format.extension())
    }
}

/// Convenience function for quick VTK output with default settings
///
/// Uses XmlNodal format (recommended) which works best with ParaView.
///
/// # Examples
/// ```ignore
/// use geo_simulator::quick_write_vtu;
///
/// quick_write_vtu(&mesh, "output/step_0001.vtu")?;
/// ```
pub fn quick_write_vtu(mesh: &Mesh, filename: &str) -> io::Result<()> {
    VtkOutputBuilder::new(mesh).write(filename)
}

/// Convenience function for VTK output with tracers
///
/// Uses XmlNodal format (recommended) which works best with ParaView.
///
/// # Examples
/// ```ignore
/// use geo_simulator::quick_write_vtu_with_tracers;
///
/// quick_write_vtu_with_tracers(&mesh, &swarm, "output/step_0001.vtu")?;
/// ```
pub fn quick_write_vtu_with_tracers(
    mesh: &Mesh,
    tracers: &TracerSwarm,
    filename: &str,
) -> io::Result<()> {
    VtkOutputBuilder::new(mesh)
        .with_tracers(tracers)
        .write(filename)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vtk_format_extension() {
        assert_eq!(VtkFormat::Legacy.extension(), ".vtk");
        assert_eq!(VtkFormat::Xml.extension(), ".vtu");
        assert_eq!(VtkFormat::XmlNodal.extension(), ".vtu");
        assert_eq!(VtkFormat::XmlMultiBlock.extension(), ".vtm");
    }

    #[test]
    fn test_format_detection() {
        assert_eq!(
            VtkFormat::from_filename("output/test.vtk"),
            Some(VtkFormat::Legacy)
        );
        assert_eq!(
            VtkFormat::from_filename("output/test.vtu"),
            Some(VtkFormat::XmlNodal)
        );
        assert_eq!(
            VtkFormat::from_filename("output/test.vtm"),
            Some(VtkFormat::XmlMultiBlock)
        );
        assert_eq!(VtkFormat::from_filename("output/test.txt"), None);
    }

    #[test]
    fn test_recommended_filename() {
        use crate::ImprovedMeshGenerator;

        let mesh = ImprovedMeshGenerator::generate_cube(2, 2, 2, 1.0, 1.0, 1.0);
        let builder = VtkOutputBuilder::new(&mesh);

        assert_eq!(
            builder.recommended_filename("output/step_0001"),
            "output/step_0001.vtu"
        );

        let builder_legacy = VtkOutputBuilder::new(&mesh).with_format(VtkFormat::Legacy);
        assert_eq!(
            builder_legacy.recommended_filename("output/step_0001"),
            "output/step_0001.vtk"
        );
    }

    #[test]
    fn test_builder_chaining() {
        use crate::ImprovedMeshGenerator;

        let mesh = ImprovedMeshGenerator::generate_cube(2, 2, 2, 1.0, 1.0, 1.0);
        let swarm = TracerSwarm::with_capacity(10);

        // Test that chaining works
        let builder = VtkOutputBuilder::new(&mesh)
            .with_tracers(&swarm)
            .with_format(VtkFormat::Legacy)
            .with_fields(&["Velocity", "Pressure"]);

        assert_eq!(builder.format, VtkFormat::Legacy);
        assert!(builder.tracers.is_some());
        assert!(builder.fields.is_some());
        assert_eq!(builder.fields.as_ref().unwrap().len(), 2);
    }
}
