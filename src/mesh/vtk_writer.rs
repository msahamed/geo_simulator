use std::fs::File;
use std::io::{self, Write};
use super::geometry::Mesh;
use super::tracers::TracerSwarm;

/// VTK file writer for unstructured grids
pub struct VtkWriter;

impl VtkWriter {
    /// Write mesh to VTK legacy format (.vtk file)
    ///
    /// The VTK cell type for Tet10 (quadratic tetrahedron) is 24
    pub fn write(mesh: &Mesh, filename: &str) -> io::Result<()> {
        let mut file = File::create(filename)?;

        // Header
        writeln!(file, "# vtk DataFile Version 3.0")?;
        writeln!(file, "Tet10 Mesh generated by geo_simulator")?;
        writeln!(file, "ASCII")?;
        writeln!(file, "DATASET UNSTRUCTURED_GRID")?;

        // Points
        writeln!(file, "POINTS {} double", mesh.num_nodes())?;
        for node in &mesh.geometry.nodes {
            writeln!(file, "{} {} {}", node.x, node.y, node.z)?;
        }

        // Cells
        let num_elements = mesh.num_elements();
        // Each tet10 element: 1 (count) + 10 (node indices) = 11 values
        let size = num_elements * 11;
        writeln!(file, "\nCELLS {} {}", num_elements, size)?;

        for elem in &mesh.connectivity.tet10_elements {
            write!(file, "10")?; // 10 nodes per element
            for &node_idx in &elem.nodes {
                write!(file, " {}", node_idx)?;
            }
            writeln!(file)?;
        }

        // Cell types (24 = VTK_QUADRATIC_TETRA)
        writeln!(file, "\nCELL_TYPES {}", num_elements)?;
        for _ in 0..num_elements {
            writeln!(file, "24")?;
        }

        // Point data (scalar and vector fields)
        if !mesh.field_data.is_empty() {
            writeln!(file, "\nPOINT_DATA {}", mesh.num_nodes())?;

            // Write scalar fields
            for field_name in mesh.field_data.field_names() {
                if let Some(field) = mesh.field_data.get_field(field_name) {
                    writeln!(file, "SCALARS {} double 1", field.name)?;
                    writeln!(file, "LOOKUP_TABLE default")?;
                    for &value in &field.data {
                        writeln!(file, "{}", value)?;
                    }
                }
            }

            // Write vector fields
            for field_name in mesh.field_data.vector_field_names() {
                if let Some(field) = mesh.field_data.get_vector_field(field_name) {
                    writeln!(file, "VECTORS {} double", field.name)?;
                    for vec in &field.data {
                        writeln!(file, "{} {} {}", vec.x, vec.y, vec.z)?;
                    }
                }
            }
        }

        // Cell data (scalar and vector fields)
        if !mesh.cell_data.is_empty() {
            writeln!(file, "\nCELL_DATA {}", mesh.num_elements())?;

            // Write scalar fields
            for field_name in mesh.cell_data.field_names() {
                if let Some(field) = mesh.cell_data.get_field(field_name) {
                    writeln!(file, "SCALARS {} double 1", field.name)?;
                    writeln!(file, "LOOKUP_TABLE default")?;
                    for &value in &field.data {
                        writeln!(file, "{}", value)?;
                    }
                }
            }

            // Write vector fields
            for field_name in mesh.cell_data.vector_field_names() {
                if let Some(field) = mesh.cell_data.get_vector_field(field_name) {
                    writeln!(file, "VECTORS {} double", field.name)?;
                    for vec in &field.data {
                        writeln!(file, "{} {} {}", vec.x, vec.y, vec.z)?;
                    }
                }
            }
        }

        Ok(())
    }

    /// Write mesh to VTU format (XML-based VTK)
    pub fn write_vtu(mesh: &Mesh, filename: &str) -> io::Result<()> {
        let mut file = File::create(filename)?;

        // XML header
        writeln!(file, "<?xml version=\"1.0\"?>")?;
        writeln!(
            file,
            "<VTKFile type=\"UnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\">"
        )?;
        writeln!(file, "  <UnstructuredGrid>")?;
        writeln!(
            file,
            "    <Piece NumberOfPoints=\"{}\" NumberOfCells=\"{}\">",
            mesh.num_nodes(),
            mesh.num_elements()
        )?;

        // Points
        writeln!(file, "      <Points>")?;
        writeln!(
            file,
            "        <DataArray type=\"Float64\" NumberOfComponents=\"3\" format=\"ascii\">"
        )?;
        for node in &mesh.geometry.nodes {
            writeln!(file, "          {} {} {}", node.x, node.y, node.z)?;
        }
        writeln!(file, "        </DataArray>")?;
        writeln!(file, "      </Points>")?;

        // Cells
        writeln!(file, "      <Cells>")?;

        // Connectivity
        writeln!(
            file,
            "        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">"
        )?;
        write!(file, "          ")?;
        for elem in &mesh.connectivity.tet10_elements {
            for &node_idx in &elem.nodes {
                write!(file, "{} ", node_idx)?;
            }
        }
        writeln!(file)?;
        writeln!(file, "        </DataArray>")?;

        // Offsets
        writeln!(
            file,
            "        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">"
        )?;
        write!(file, "          ")?;
        for i in 1..=mesh.num_elements() {
            write!(file, "{} ", i * 10)?;
        }
        writeln!(file)?;
        writeln!(file, "        </DataArray>")?;

        // Types (24 = VTK_QUADRATIC_TETRA)
        writeln!(
            file,
            "        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">"
        )?;
        write!(file, "          ")?;
        for _ in 0..mesh.num_elements() {
            write!(file, "24 ")?;
        }
        writeln!(file)?;
        writeln!(file, "        </DataArray>")?;

        writeln!(file, "      </Cells>")?;

        // Point data (scalar and vector fields)
        if !mesh.field_data.is_empty() {
            writeln!(file, "      <PointData>")?;

            // Write scalar fields
            for field_name in mesh.field_data.field_names() {
                if let Some(field) = mesh.field_data.get_field(field_name) {
                    writeln!(
                        file,
                        "        <DataArray type=\"Float64\" Name=\"{}\" format=\"ascii\">",
                        field.name
                    )?;
                    write!(file, "          ")?;
                    for &value in &field.data {
                        write!(file, "{} ", value)?;
                    }
                    writeln!(file)?;
                    writeln!(file, "        </DataArray>")?;
                }
            }

            // Write vector fields
            for field_name in mesh.field_data.vector_field_names() {
                if let Some(field) = mesh.field_data.get_vector_field(field_name) {
                    writeln!(
                        file,
                        "        <DataArray type=\"Float64\" Name=\"{}\" NumberOfComponents=\"3\" format=\"ascii\">",
                        field.name
                    )?;
                    write!(file, "          ")?;
                    for vec in &field.data {
                        write!(file, "{} {} {} ", vec.x, vec.y, vec.z)?;
                    }
                    writeln!(file)?;
                    writeln!(file, "        </DataArray>")?;
                }
            }

            writeln!(file, "      </PointData>")?;
        }

        // Cell data (scalar and vector fields)
        if !mesh.cell_data.is_empty() {
            writeln!(file, "      <CellData>")?;

            // Write scalar fields
            for field_name in mesh.cell_data.field_names() {
                if let Some(field) = mesh.cell_data.get_field(field_name) {
                    writeln!(
                        file,
                        "        <DataArray type=\"Float64\" Name=\"{}\" format=\"ascii\">",
                        field.name
                    )?;
                    write!(file, "          ")?;
                    for &value in &field.data {
                        write!(file, "{} ", value)?;
                    }
                    writeln!(file)?;
                    writeln!(file, "        </DataArray>")?;
                }
            }

            // Write vector fields
            for field_name in mesh.cell_data.vector_field_names() {
                if let Some(field) = mesh.cell_data.get_vector_field(field_name) {
                    writeln!(
                        file,
                        "        <DataArray type=\"Float64\" Name=\"{}\" NumberOfComponents=\"3\" format=\"ascii\">",
                        field.name
                    )?;
                    write!(file, "          ")?;
                    for vec in &field.data {
                        write!(file, "{} {} {} ", vec.x, vec.y, vec.z)?;
                    }
                    writeln!(file)?;
                    writeln!(file, "        </DataArray>")?;
                }
            }

            writeln!(file, "      </CellData>")?;
        }

        writeln!(file, "    </Piece>")?;
        writeln!(file, "  </UnstructuredGrid>")?;
        writeln!(file, "</VTKFile>")?;

        Ok(())
    }

    /// Write tracers to VTU format (as a cloud of points)
    pub fn write_tracers_vtu(tracers: &TracerSwarm, filename: &str) -> io::Result<()> {
        let mut file = File::create(filename)?;
        let num_points = tracers.num_tracers();

        // XML header
        writeln!(file, "<?xml version=\"1.0\"?>")?;
        writeln!(
            file,
            "<VTKFile type=\"UnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\">"
        )?;
        writeln!(file, "  <UnstructuredGrid>")?;
        writeln!(
            file,
            "    <Piece NumberOfPoints=\"{}\" NumberOfCells=\"{}\">",
            num_points,
            num_points // Each point is its own cell (VTK_VERTEX)
        )?;

        // Points
        writeln!(file, "      <Points>")?;
        writeln!(
            file,
            "        <DataArray type=\"Float64\" NumberOfComponents=\"3\" format=\"ascii\">"
        )?;
        for i in 0..num_points {
            writeln!(file, "          {} {} {}", tracers.x[i], tracers.y[i], tracers.z[i])?;
        }
        writeln!(file, "        </DataArray>")?;
        writeln!(file, "      </Points>")?;

        // Cells (Vertices)
        writeln!(file, "      <Cells>")?;
        writeln!(file, "        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for i in 0..num_points {
            write!(file, "{} ", i)?;
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for i in 1..=num_points {
            write!(file, "{} ", i)?;
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for _ in 0..num_points {
            write!(file, "1 ")?; // 1 = VTK_VERTEX
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "      </Cells>")?;

        // Point Data
        writeln!(file, "      <PointData>")?;
        
        // Material ID
        writeln!(file, "        <DataArray type=\"UInt32\" Name=\"MaterialID\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &id in &tracers.material_id {
            write!(file, "{} ", id)?;
        }
        writeln!(file, "\n        </DataArray>")?;

        // Velocity (Vector)
        if !tracers.vx.is_empty() {
            writeln!(file, "        <DataArray type=\"Float64\" Name=\"Velocity\" NumberOfComponents=\"3\" format=\"ascii\">")?;
            for i in 0..num_points {
                writeln!(file, "          {} {} {}", tracers.vx[i], tracers.vy[i], tracers.vz[i])?;
            }
            writeln!(file, "        </DataArray>")?;
        }

        // Plastic Strain
        writeln!(file, "        <DataArray type=\"Float64\" Name=\"PlasticStrain\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &eps in &tracers.plastic_strain {
            write!(file, "{} ", eps)?;
        }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "      </PointData>")?;

        writeln!(file, "    </Piece>")?;
        writeln!(file, "  </UnstructuredGrid>")?;
        writeln!(file, "</VTKFile>")?;

        Ok(())
    }

    /// Write both mesh and tracers into a single VTU file using multiple pieces
    pub fn write_combined_vtu(mesh: &Mesh, tracers: &TracerSwarm, filename: &str) -> io::Result<()> {
        let mut file = File::create(filename)?;

        // XML header
        writeln!(file, "<?xml version=\"1.0\"?>")?;
        writeln!(
            file,
            "<VTKFile type=\"UnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\">"
        )?;
        writeln!(file, "  <UnstructuredGrid>")?;

        // --------------------------------------------------------------------
        // Piece 1: The Mesh (Elements)
        // --------------------------------------------------------------------
        writeln!(
            file,
            "    <Piece NumberOfPoints=\"{}\" NumberOfCells=\"{}\">",
            mesh.num_nodes(),
            mesh.num_elements()
        )?;

        // Points
        writeln!(file, "      <Points>")?;
        writeln!(file, "        <DataArray type=\"Float64\" NumberOfComponents=\"3\" format=\"ascii\">")?;
        for node in &mesh.geometry.nodes {
            writeln!(file, "          {} {} {}", node.x, node.y, node.z)?;
        }
        writeln!(file, "        </DataArray>")?;
        writeln!(file, "      </Points>")?;

        // Cells
        writeln!(file, "      <Cells>")?;
        writeln!(file, "        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for elem in &mesh.connectivity.tet10_elements {
            for &node_idx in &elem.nodes {
                write!(file, "{} ", node_idx)?;
            }
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for i in 1..=mesh.num_elements() {
            write!(file, "{} ", i * 10)?;
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for _ in 0..mesh.num_elements() {
            write!(file, "24 ")?; // VTK_QUADRATIC_TETRA
        }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "      </Cells>")?;

        // Mesh Point Data
        if !mesh.field_data.is_empty() {
            writeln!(file, "      <PointData>")?;
            for field_name in mesh.field_data.field_names() {
                if let Some(field) = mesh.field_data.get_field(field_name) {
                    writeln!(file, "        <DataArray type=\"Float64\" Name=\"{}\" format=\"ascii\">", field.name)?;
                    write!(file, "          ")?;
                    for &value in &field.data { let _ = write!(file, "{} ", value); }
                    writeln!(file, "\n        </DataArray>")?;
                }
            }
            for field_name in mesh.field_data.vector_field_names() {
                if let Some(field) = mesh.field_data.get_vector_field(field_name) {
                    writeln!(file, "        <DataArray type=\"Float64\" Name=\"{}\" NumberOfComponents=\"3\" format=\"ascii\">", field.name)?;
                    for vec in &field.data {
                        writeln!(file, "          {} {} {}", vec.x, vec.y, vec.z)?;
                    }
                    writeln!(file, "        </DataArray>")?;
                }
            }
            writeln!(file, "      </PointData>")?;
        }

        // Mesh Cell Data
        if !mesh.cell_data.is_empty() {
            writeln!(file, "      <CellData>")?;
            for field_name in mesh.cell_data.field_names() {
                if let Some(field) = mesh.cell_data.get_field(field_name) {
                    writeln!(file, "        <DataArray type=\"Float64\" Name=\"{}\" format=\"ascii\">", field.name)?;
                    write!(file, "          ")?;
                    for &value in &field.data { let _ = write!(file, "{} ", value); }
                    writeln!(file, "\n        </DataArray>")?;
                }
            }
            writeln!(file, "      </CellData>")?;
        }
        writeln!(file, "    </Piece>")?;

        // --------------------------------------------------------------------
        // Piece 2: The Tracers (Points)
        // --------------------------------------------------------------------
        let num_tracers = tracers.num_tracers();
        writeln!(
            file,
            "    <Piece NumberOfPoints=\"{}\" NumberOfCells=\"{}\">",
            num_tracers,
            num_tracers
        )?;

        // Points
        writeln!(file, "      <Points>")?;
        writeln!(file, "        <DataArray type=\"Float64\" NumberOfComponents=\"3\" format=\"ascii\">")?;
        for i in 0..num_tracers {
            writeln!(file, "          {} {} {}", tracers.x[i], tracers.y[i], tracers.z[i])?;
        }
        writeln!(file, "        </DataArray>")?;
        writeln!(file, "      </Points>")?;

        // Cells
        writeln!(file, "      <Cells>")?;
        writeln!(file, "        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for i in 0..num_tracers { write!(file, "{} ", i)?; }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for i in 1..=num_tracers { write!(file, "{} ", i)?; }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for _ in 0..num_tracers { write!(file, "1 ")?; } // VTK_VERTEX
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "      </Cells>")?;

        // Tracer Data
        writeln!(file, "      <PointData>")?;
        writeln!(file, "        <DataArray type=\"Float64\" Name=\"MaterialID\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &id in &tracers.material_id { write!(file, "{} ", id)?; }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"Float64\" Name=\"PlasticStrain\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &eps in &tracers.plastic_strain { write!(file, "{} ", eps)?; }
        writeln!(file, "\n        </DataArray>")?;
        writeln!(file, "        <DataArray type=\"Float64\" Name=\"Stress_II\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &val in &tracers.stress_ii { write!(file, "{} ", val)?; }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "        <DataArray type=\"Float64\" Name=\"StrainRate_II\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &val in &tracers.strain_rate_ii { write!(file, "{} ", val)?; }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "        <DataArray type=\"Float64\" Name=\"Viscosity\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &val in &tracers.viscosity { write!(file, "{} ", val)?; }
        writeln!(file, "\n        </DataArray>")?;

        writeln!(file, "        <DataArray type=\"Float64\" Name=\"Pressure\" format=\"ascii\">")?;
        write!(file, "          ")?;
        for &val in &tracers.pressure { write!(file, "{} ", val)?; }
        writeln!(file, "\n        </DataArray>")?;

        if !tracers.vx.is_empty() {
            writeln!(file, "        <DataArray type=\"Float64\" Name=\"Velocity\" NumberOfComponents=\"3\" format=\"ascii\">")?;
            for i in 0..num_tracers {
                writeln!(file, "          {} {} {}", tracers.vx[i], tracers.vy[i], tracers.vz[i])?;
            }
            writeln!(file, "        </DataArray>")?;
        }
        writeln!(file, "      </PointData>")?;

        writeln!(file, "    </Piece>")?;

        writeln!(file, "  </UnstructuredGrid>")?;
        writeln!(file, "</VTKFile>")?;

        Ok(())
    }
}
